generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                String             @id @default(cuid())
  clerkId           String             @unique
  email             String             @unique
  username          String             @unique
  displayName       String?
  avatarUrl         String?
  level             Int                @default(1)
  xp                Int                @default(0)
  xpToNextLevel     Int                @default(1000)
  tokenBalance      Int                @default(0)
  bonusPoints       Int                @default(0)
  totalEarned       Int                @default(0)
  referralCode      String             @unique
  referredById      String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  lastLoginAt       DateTime?
  dailyStreaks      DailyStreak?
  nftBids           NFTBid[]
  notifications     Notification[]
  referralStats     ReferralStats?
  tokenTransactions TokenTransaction[]
  referredBy        User?              @relation("Referrals", fields: [referredById], references: [id])
  referrals         User[]             @relation("Referrals")
  achievements      UserAchievement[]
  gameProgress      UserGameProgress[]
  ownedNFTs         UserNFT[]
  tasks             UserTask[]
  wallet            Wallet?

  @@index([clerkId])
  @@index([referralCode])
  @@index([referredById])
}

model Wallet {
  id           String              @id @default(cuid())
  userId       String              @unique
  address      String              @unique
  network      NetworkType         @default(VARA_TESTNET)
  isConnected  Boolean             @default(false)
  varaBalance  Float               @default(0)
  lineBalance  Float               @default(0)
  connectedAt  DateTime?
  lastSyncedAt DateTime?
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  user         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions WalletTransaction[]

  @@index([address])
}

model WalletTransaction {
  id          String                @id @default(cuid())
  walletId    String
  type        WalletTransactionType
  status      TransactionStatus     @default(PENDING)
  tokenType   TokenType
  amount      Float
  fromAddress String
  toAddress   String
  txHash      String?               @unique
  nftId       String?
  createdAt   DateTime              @default(now())
  confirmedAt DateTime?
  nft         NFT?                  @relation(fields: [nftId], references: [id])
  wallet      Wallet                @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@index([walletId])
  @@index([txHash])
  @@index([status])
}

model TokenTransaction {
  id        String               @id @default(cuid())
  userId    String
  type      TokenTransactionType
  amount    Int
  balance   Int
  source    String
  metadata  Json?
  createdAt DateTime             @default(now())
  user      User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([createdAt])
}

model Game {
  id               String             @id @default(cuid())
  slug             String             @unique
  name             String
  description      String
  shortDescription String?
  coverImage       String
  bannerImage      String?
  screenshots      String[]
  category         GameCategory
  tags             String[]
  playerCount      Int                @default(0)
  rating           Float              @default(0)
  ratingCount      Int                @default(0)
  rewardMin        Int                @default(0)
  rewardMax        Int                @default(0)
  status           GameStatus         @default(COMING_SOON)
  releaseDate      DateTime?
  minPlayers       Int                @default(1)
  maxPlayers       Int                @default(1)
  avgPlayTime      Int?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  achievements     Achievement[]
  userProgress     UserGameProgress[]

  @@index([category])
  @@index([status])
}

model UserGameProgress {
  id            String    @id @default(cuid())
  userId        String
  gameId        String
  gamesPlayed   Int       @default(0)
  wins          Int       @default(0)
  losses        Int       @default(0)
  highScore     Int       @default(0)
  totalScore    Int       @default(0)
  totalPlayTime Int       @default(0)
  tokensEarned  Int       @default(0)
  lastPlayedAt  DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  game          Game      @relation(fields: [gameId], references: [id], onDelete: Cascade)
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, gameId])
  @@index([userId])
  @@index([gameId])
}

model NFT {
  id              String              @id @default(cuid())
  tokenId         String?             @unique
  contractAddress String?
  name            String
  description     String?
  image           String
  creatorId       String?
  creatorName     String
  rarity          NFTRarity
  collection      String?
  attributes      Json?
  currentPrice    Float?
  lastSalePrice   Float?
  likes           Int                 @default(0)
  views           Int                 @default(0)
  mintedAt        DateTime?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  bids            NFTBid[]
  listings        NFTListing[]
  owners          UserNFT[]
  walletTxns      WalletTransaction[]

  @@index([rarity])
  @@index([collection])
}

model NFTListing {
  id        String           @id @default(cuid())
  nftId     String
  sellerId  String
  price     Float
  tokenType TokenType        @default(LINE)
  status    NFTListingStatus @default(LISTED)
  expiresAt DateTime?
  createdAt DateTime         @default(now())
  soldAt    DateTime?
  bids      NFTBid[]
  nft       NFT              @relation(fields: [nftId], references: [id], onDelete: Cascade)

  @@index([nftId])
  @@index([status])
  @@index([sellerId])
}

model NFTBid {
  id        String     @id @default(cuid())
  listingId String
  nftId     String
  bidderId  String
  amount    Float
  tokenType TokenType  @default(LINE)
  isWinning Boolean    @default(false)
  createdAt DateTime   @default(now())
  bidder    User       @relation(fields: [bidderId], references: [id], onDelete: Cascade)
  listing   NFTListing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  nft       NFT        @relation(fields: [nftId], references: [id], onDelete: Cascade)

  @@index([listingId])
  @@index([bidderId])
  @@index([nftId])
}

model UserNFT {
  id          String   @id @default(cuid())
  userId      String
  nftId       String
  acquiredAt  DateTime @default(now())
  acquiredFor Float?
  isFavorite  Boolean  @default(false)
  nft         NFT      @relation(fields: [nftId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, nftId])
  @@index([userId])
  @@index([nftId])
}

model Task {
  id             String     @id @default(cuid())
  slug           String     @unique
  name           String
  description    String
  type           TaskType
  reward         Int
  xpReward       Int        @default(0)
  targetProgress Int        @default(1)
  externalUrl    String?
  icon           String?
  isActive       Boolean    @default(true)
  isRepeatable   Boolean    @default(false)
  resetPeriod    String?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  userTasks      UserTask[]

  @@index([type])
  @@index([isActive])
}

model UserTask {
  id          String     @id @default(cuid())
  userId      String
  taskId      String
  status      TaskStatus @default(ACTIVE)
  progress    Int        @default(0)
  startedAt   DateTime   @default(now())
  completedAt DateTime?
  claimedAt   DateTime?
  periodStart DateTime?
  task        Task       @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, taskId, periodStart])
  @@index([userId])
  @@index([taskId])
  @@index([status])
}

model Achievement {
  id               String            @id @default(cuid())
  slug             String            @unique
  name             String
  description      String
  icon             String
  xpReward         Int               @default(0)
  tokenReward      Int               @default(0)
  targetValue      Int               @default(1)
  gameId           String?
  sortOrder        Int               @default(0)
  isHidden         Boolean           @default(false)
  createdAt        DateTime          @default(now())
  game             Game?             @relation(fields: [gameId], references: [id])
  userAchievements UserAchievement[]

  @@index([gameId])
}

model UserAchievement {
  id            String      @id @default(cuid())
  userId        String
  achievementId String
  progress      Int         @default(0)
  isUnlocked    Boolean     @default(false)
  unlockedAt    DateTime?
  claimedAt     DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId])
  @@index([achievementId])
  @@index([isUnlocked])
}

model DailyStreak {
  id              String    @id @default(cuid())
  userId          String    @unique
  currentStreak   Int       @default(0)
  longestStreak   Int       @default(0)
  lastClaimDate   DateTime?
  streakStartDate DateTime?
  claimedDays     Int[]     @default([])
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model StreakReward {
  id     String @id @default(cuid())
  day    Int    @unique
  reward Int

  @@index([day])
}

model ReferralStats {
  id              String   @id @default(cuid())
  userId          String   @unique
  totalReferrals  Int      @default(0)
  activeReferrals Int      @default(0)
  totalEarned     Int      @default(0)
  currentTier     Int      @default(1)
  commissionRate  Float    @default(0.05)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model ReferralTier {
  id                String  @id @default(cuid())
  tier              Int     @unique
  requiredReferrals Int
  reward            Int
  commissionRate    Float
  bonus             String?

  @@index([tier])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  title     String
  message   String
  type      String
  isRead    Boolean  @default(false)
  metadata  Json?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
}

enum GameCategory {
  RACING
  ACTION
  ADVENTURE
  CARDS
  STRATEGY
  PUZZLE
  RPG
  SIMULATION
}

enum GameStatus {
  ACTIVE
  COMING_SOON
  MAINTENANCE
  DEPRECATED
}

enum NFTRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
  MYTHIC
}

enum NFTListingStatus {
  LISTED
  SOLD
  CANCELLED
  EXPIRED
}

enum TaskType {
  DAILY
  EXTERNAL
  ACHIEVEMENT
  ONBOARDING
}

enum TaskStatus {
  ACTIVE
  COMPLETED
  EXPIRED
  CLAIMED
}

enum TokenTransactionType {
  EARN
  SPEND
  TRANSFER
  CLAIM
  REFERRAL_BONUS
  GAME_REWARD
  DAILY_REWARD
  STREAK_BONUS
  ACHIEVEMENT_REWARD
}

enum WalletTransactionType {
  SEND
  RECEIVE
  WITHDRAW
  NFT_PURCHASE
  NFT_SALE
  SWAP
  STAKE
  UNSTAKE
}

enum TransactionStatus {
  PENDING
  CONFIRMED
  FAILED
  CANCELLED
}

enum TokenType {
  VARA
  LINE
}

enum NetworkType {
  VARA_MAINNET
  VARA_TESTNET
}

enum ReferralStatus {
  ACTIVE
  INACTIVE
  BANNED
}
